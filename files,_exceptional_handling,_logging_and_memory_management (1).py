# -*- coding: utf-8 -*-
"""Files, exceptional handling, logging and memory management.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B0MNhtI52eCS_Ww53uGJ-woHx9AwIWMZ

# Files, exceptional handling, logging and memory management Questions

Q.1 What is the difference between interpreted and compiled languages?

     --> The main difference is the timing and process of code execution: a compiled language converts the entire source code into machine-readable code (machine code) before runtime, resulting in faster execution but platform dependency, while an interpreted language translates and executes the source code line-by-line during runtime using an interpreter, offering more flexibility and portability but slower performance.

     Compiled Languages-

     Process:
             A compiler translates the entire source code into machine code before the program is run. This machine code is then executed directly by the computer's CPU. A compiler translates the entire source code into machine code before the program is run. This machine code is then executed directly by the computer's CPU.

      Execution:
            After compilation, the program can be run independently without the source code or the compiler itself.

      Speed:
           Compiled programs run faster because the entire translation is done upfront, and the CPU executes native machine code.

      Error Detection:
          Compilers perform extensive error checking during the compilation phase, leading to early error detection.

      Platform Dependence:
          Compiled code is specific to the target architecture, meaning a program compiled for one operating system or hardware might not run on another.  

      Examples:
          C, C++, Go.     

      Interpreted Languages-

      Process:
          An interpreter reads and executes the source code line by line during runtime.

      Execution:
          The interpreter translates each line of code as it's encountered and then executes it, requiring the interpreter to be present on the machine where the code runs.

      Speed:
          Interpreted languages generally run slower due to the overhead of line-by-line translation during execution.

      Error Detection:
          Errors are found as the program runs, often appearing only when the problematic line is reached.

      Platform Independence:
          The source code can be run on any system that has the correct interpreter installed, making them more portable.

      Examples:
          JavaScript, PHP.

Q.2 What is exception handling in Python?

     --> Exception handling in Python is a mechanism that allows programs to gracefully manage and respond to runtime errors, known as exceptions, without crashing the entire program. It ensures that the program can continue to execute or exit in a controlled manner, even when unexpected events occur.

Q.3 What is the purpose of the finally block in exception handling?

     --> The primary purpose of a finally block is to ensure that a specific piece of code, known as cleanup code, executes regardless of whether an exception occurs in the try block or is caught by a catch block. This guarantees that resources like file streams, network connections, or database connections are properly closed, preventing resource leaks and ensuring the program's stability.

Q.4 What is logging in Python?

     --> Logging in Python refers to the process of recording events that occur during the execution of a software program. It is a fundamental practice for software development, debugging, and monitoring, allowing developers to track the flow of an application, identify issues, and gain insights into its behavior.

     Instead of relying solely on print() statements for debugging, Python's built-in logging module provides a more structured and robust approach. This module enables the recording of messages at various severity levels (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL) and offers flexible configuration options for directing these messages to different destinations, such as the console, files, or even remote servers.

Q.5 What is the significance of the __del__ method in Python?
    
     --> The __del__ method in Python, often referred to as a destructor, holds significance primarily for resource cleanup when an object is about to be destroyed.

Q.6  What is the difference between import and from ... import in Python?
  
      --> In Python, both import and from ... import statements are used to bring modules or specific components from modules into the current namespace, but they differ in how they achieve this:

      * import module_name:

          ~ This statement imports the entire module_name and makes it available as an object in the current namespace.
           
          ~ To access any function, class, or variable within that module, you must prefix it with the module name and a dot (e.g., module_name.function()).

          ~ This approach avoids naming conflicts if multiple modules contain elements with the same name, as each element is clearly associated with its originating module.

              import math
              result = math.sqrt(25)
              print(result) # Output: 5.0

         * from module_name import specific_item:

           ~ This statement imports only the specific_item (e.g., a function, class, or variable) from module_name directly into the current namespace.

           ~ You can then use the specific_item directly without needing to prefix it with the module name.

           ~ This can lead to naming conflicts if you import items with the same name from different modules or if they conflict with existing names in your current script.

              from math import sqrt
              result = sqrt(25)
              print(result) # Output: 5.0

Q.7  How can you handle multiple exceptions in Python?

      --> Multiple exceptions in Python can be handled within a try-except block using a few different methods: multiple except blocks.

      This approach involves using separate except blocks for each specific exception type that needs distinct handling. Only the except block corresponding to the raised exception will be executed.

Q.8 What is the purpose of the with statement when handling files in Python?

     --> The with statement in Python, when used for file handling, serves the primary purpose of ensuring that file resources are properly managed and released. This includes:

     * Automatic Resource Cleanup:
         - The with statement guarantees that the file is automatically closed after the code block within the with statement is executed, even if errors or exceptions occur during file operations. This prevents resource leaks and potential file corruption.

     * Simplified Code:
         - It eliminates the need for explicit try-finally blocks to ensure file closure, making the code cleaner, more readable, and less prone to errors related to unclosed files.

     * How it works:
         - When you use with open(...) as file:, the open() function returns a file object, and the with statement ensures that the __enter__ method of this file object is called upon entry to the block and the __exit__ method is called upon exiting the block. The __exit__ method handles the file closing, regardless of how the block is exited (normally or due to an exception).

     Example:

             with open("my_file.txt", "w") as file:
             file.write("This is some text.")
             # The file is automatically closed here, even if an error occurred during write.

Q.9 What is the difference between multithreading and multiprocessing?

     --> Multithreading

         * Unit of Execution: Threads within a single process.

         * Memory: Threads share the same memory space, allowing for easy data sharing.

         * Overhead: Low overhead for creating and switching between threads.

         * Use Case: Ideal for I/O-bound tasks (like network requests or reading files) where the application needs to remain responsive while waiting for external resources.

         * Parallelism: Provides concurrency (tasks appearing to run at the same time), but often limited true parallelism on single cores due to Global Interpreter Locks (GILs) in some languages like Python.

         * Example: A web browser with multiple tabs â€“ each tab is a thread in the same browser process.

     --> Multiprocessing

        * Unit of Execution: Independent processes.

        * Memory: Each process has its own separate memory space, making data sharing more complex.

        * Overhead: High overhead and more time-consuming to create new processes.

        * Use Case: Suited for CPU-bound tasks that require significant processing power, as it can distribute these tasks across multiple CPU cores for true parallel execution.

        * Parallelism: Achieves true parallelism by running processes on different CPU cores, bypassing GIL limitations.

        * Example: Training a large AI model, where the workload can be divided and processed on multiple CPU cores simultaneously.

Q.10 What are the advantages of using logging in a program?

      --> Using logging in a program offers several significant advantages:

          * Debugging and Troubleshooting:
            - Logs provide a chronological record of events within an application, making it easier to identify the root cause of errors, unexpected behavior, or performance issues. This is especially crucial in production environments where direct debugging is often not feasible.

          * Monitoring and Performance Analysis:
            - Logs can be used to track application performance metrics, resource utilization, and user activity. This data helps in understanding how the application behaves in real-world scenarios, identifying bottlenecks, and optimizing performance.

          * Security Auditing and Compliance:
           - Logging user actions, system events, and security-related information helps in maintaining an audit trail, detecting suspicious activity, and ensuring compliance with regulatory requirements.

          * Understanding Application Flow and Behavior:
            - By strategically placing log statements, developers can gain insights into the execution flow of their code, the values of variables at different stages, and how various components interact. This aids in understanding complex systems and verifying expected behavior.  

          * Reduced Development Time:
           - Well-structured and informative logs can significantly reduce the time spent on debugging and understanding code, leading to faster development cycles.

Q.11 What is memory management in Python?

      --> Memory management in Python refers to the system that handles the allocation and deallocation of memory resources for Python objects during program execution. Unlike languages like C or C++, Python automates this process, relieving the developer from manual memory management.

Q.12 What are the basic steps involved in exception handling in Python?

      --> Exception handling in Python primarily involves the use of try, except, else, and finally blocks to manage potential errors during program execution.

      * try block:
        - This block contains the code that is susceptible to raising an exception. Python attempts to execute the code within this block. If an exception occurs, the remaining code in the try block is skipped, and control is transferred to the appropriate except block.

      * except block:
        - This block follows the try block and is designed to handle specific or general exceptions that might be raised in the try block. When an exception occurs, Python searches for a matching except block. If a match is found, the code within that except block is executed, allowing for error recovery or graceful handling. Multiple except blocks can be used to handle different types of exceptions.

      * else block (optional):
        - This block can be included after all except blocks. The code within the else block executes only if no exception was raised within the try block. It is useful for code that should only run upon successful execution of the try block.

      * finally block (optional):
        - This block, if present, always executes regardless of whether an exception occurred or not, and regardless of whether it was handled. It is typically used for cleanup operations, such as closing files or releasing resources, ensuring these actions happen even in the presence of errors.

Q.13 Why is memory management important in Python?

      --> Memory management is crucial in Python, even though it handles much of it automatically, for several key reasons:

      * Efficiency and Performance:
        - Efficient memory management ensures that programs use only the necessary amount of memory. This prevents excessive memory consumption, which can lead to slower execution, resource contention, and even system crashes, especially in applications dealing with large datasets or running for extended periods.

      * Resource Optimization:
        - Python's automatic memory management (through mechanisms like reference counting and garbage collection) aims to reclaim memory occupied by objects no longer in use. Understanding how this works helps developers write code that allows these mechanisms to function effectively, freeing up resources for other parts of the program or other applications.

      * Preventing Memory Leaks:
        - Improper memory handling, even in a language with automatic management, can lead to memory leaks where memory is allocated but never released, even after the objects are no longer needed. This can degrade application performance over time and eventually lead to out-of-memory errors.

      * Debugging and Troubleshooting:
        - A grasp of Python's memory model helps in diagnosing and resolving memory-related issues, such as unexpected memory usage patterns or performance bottlenecks. It allows developers to identify potential areas for optimization in their code.

      * Writing Optimized Code:
        - While Python simplifies memory management, knowledge of its inner workings (e.g., how different data structures consume memory, the impact of object overhead) enables developers to make informed choices about data structures and algorithms, leading to more memory-efficient and performant code. For instance, using generators for large datasets can significantly reduce memory footprint compared to loading the entire dataset into memory.

Q.14 What is the role of try and except in exception handling?

      --> The try and except statements are fundamental components of exception handling in programming, particularly in languages like Python. Their primary role is to gracefully manage errors that occur during program execution, preventing abrupt termination and allowing for a more robust and user-friendly application.
      
      * try block:
        - This block encloses the code that is anticipated to potentially raise an exception. The program attempts to execute the code within the try block. If no exception occurs, the code runs normally, and the corresponding except block is skipped.

      * except block:
        - This block is executed only if an exception is raised within its corresponding try block. It provides a mechanism to catch and handle specific types of exceptions, or a general exception if no specific type is mentioned. The code within the except block typically contains logic to manage the error, such as logging the error, providing a user-friendly message, or attempting to recover from the error.

Q.15 How does Python's garbage collection system work?

      --> Python's garbage collection system employs a hybrid approach primarily relying on reference counting and supplemented by a generational garbage collector to handle cyclic references.

      Reference Counting:

      * This is the primary mechanism for memory management.

      * Every object in Python maintains a reference count, which tracks the number of references pointing to it.

      * When an object is created, its reference count is initialized.

      * The reference count increments when a new reference to the object is created (e.g., assigning it to another variable) and decrements when a reference is removed (e.g., variable goes out of scope, reassignment, or explicit deletion).

      * When an object's reference count drops to zero, it means no variables or other objects are referencing it, making it eligible for immediate deallocation, and its memory is reclaimed.

Q.16 What is the purpose of the else block in exception handling?

      --> The purpose of the else block in exception handling, particularly in Python's try...except...else structure, is to execute a block of code only if no exception is raised within the corresponding try block.

      This allows for a clear separation of concerns:

      * try block: Contains the code that might potentially raise an exception.

      * except block(s): Handle specific types of exceptions if they occur in the try block.

      * else block: Contains code that should run only when the try block executes successfully without any exceptions.

      This structure is beneficial for scenarios where certain actions are contingent on the successful completion of the code within the try block, and you want to avoid performing those actions if an error occurred. It helps in maintaining cleaner code by isolating the "success" path from the "error handling" path.

Q.17 What are the common logging levels in Python?

     --> Python's logging module provides several standard logging levels to categorize the severity of events. These levels, from lowest to highest severity, are:

     * DEBUG:
       - Detailed information, typically useful only when diagnosing problems or during development.

     * INFO:
       - Confirmation that things are working as expected, providing general information about the application's normal operation.

     * WARNING:
       - An indication that something unexpected happened, or a potential problem might arise soon. The software is still functioning as expected, but attention may be required.

     * ERROR:
       - A more serious problem that has prevented the software from performing some functions. This indicates a significant issue that needs addressing.

     * CRITICAL:
       - A severe error indicating that the program itself may be unable to continue running. This level often signifies a fatal error leading to application termination.

Q.18  What is the difference between os.fork() and multiprocessing in Python?

       --> The core difference between os.fork() and Python's multiprocessing module lies in their level of abstraction and portability:

       * os.fork() (Low-Level System Call):
      
      ~  Direct System Call: os.fork() is a direct wrapper around the Unix/Linux fork() system call. It creates a new process (the "child") that is an exact copy of the calling process (the "parent").

      ~ Copy-on-Write: The child process initially shares the parent's memory pages using a copy-on-write mechanism, meaning pages are only duplicated when modified by either process.

      ~ Unix-Specific: os.fork() is only available on Unix-like operating systems (Linux, macOS, etc.) and is not supported on Windows.

      ~ Manual Management: You are responsible for managing the child process, including waiting for its completion (os.waitpid()) and handling inter-process communication (IPC) if needed.

      * multiprocessing Module (High-Level Abstraction):

      ~ Cross-Platform: The multiprocessing module provides a higher-level, cross-platform API for creating and managing processes, working on Windows, Linux, and macOS.

      ~ Process Start Methods: It offers different "start methods" for creating new processes:

        - fork (default on Linux): Similar to os.fork(), but handled by the module.

        - spawn (default on Windows and macOS): Starts a fresh Python interpreter process, providing better isolation and avoiding issues with inherited resources.

        - forkserver: A hybrid approach where a server process is forked, and subsequent child processes are spawned from this server.

      ~ Simplified Management: The module handles much of the complexity of process management, including cleanup, and provides tools for IPC (queues, pipes, shared memory) and synchronization (locks, events).

      ~ Focus on Concurrency: It's designed to facilitate concurrent execution of tasks, often used in scenarios like parallelizing CPU-bound computations.

Q.19 What is the importance of closing a file in Python?

      --> Closing a file in Python is crucial for several reasons, primarily related to resource management and data integrity:

      * Resource Release:
        - When a file is opened, the operating system allocates resources to manage it. Failing to close a file means these resources are not released, leading to potential resource leaks, especially in long-running applications or those handling many files. This can exhaust the available file handles, preventing the program from opening new files or even causing system-wide issues.

      * Data Integrity:
        - When writing data to a file, Python often uses internal buffers to optimize performance. Data might not be immediately written to the disk but held in these buffers. Closing the file explicitly flushes these buffers, ensuring that all written data is committed to the storage medium, thus preventing data loss or corruption in case of program termination or system crashes.

      * File Locking and Access:
        - In some operating systems or scenarios, an open file might be locked, preventing other processes or users from accessing or modifying it. Closing the file releases these locks, allowing other applications or users to interact with the file.

      * Best Practice and Code Robustness:
        - Explicitly closing files is considered a good programming practice. It makes the code more predictable and robust, reducing the likelihood of unexpected behavior or errors related to file handling. The with statement in Python is highly recommended for file handling as it automatically ensures files are closed, even if exceptions occur.

Q.20 What is the difference between file.read() and file.readline() in Python?

      --> In Python, file.read() and file.readline() are methods used to read data from a file object, but they differ in how much data they retrieve:

      * file.read(): This method reads the entire content of the file and returns it as a single string. It can optionally take an integer argument size, which specifies the number of characters or bytes to read from the current position. If size is not provided, the entire file content is read.

               with open("example.txt", "r") as file:
               content = file.read()
               print(content)

       * file.readline(): This method reads a single line from the file at a time, including the newline character (\n) if present, and returns it as a string. It stops reading when it encounters a newline character or reaches the end of the file. If the end of the file is reached and no more lines are available, it returns an empty string.

                    with open("example.txt", "r") as file:
                    line1 = file.readline()
                    line2 = file.readline()
                    print(line1)
                    print(line2)

Q.21 What is the logging module in Python used for?

      --> The logging module in Python is a part of the standard library and provides a flexible and powerful framework for emitting log messages from applications. Its primary uses include:

      * Tracking Events:
        - Recording significant events that occur during program execution, such as successful operations, configuration changes, or user interactions.

      * Debugging and Troubleshooting:
        - Providing detailed information about the program's state at specific points, which is invaluable for identifying and resolving issues. This includes error messages, warnings, and debug-level information.

      * Monitoring Application Health:
       - Collecting data about performance, resource usage, and potential problems, allowing developers to monitor the application's health and proactively address issues.  

      * Auditing and Compliance:
        - Creating a record of activities for auditing purposes, especially in applications with security or regulatory compliance requirements.

Q.22 What is the os module in Python used for in file handling?

      --> The os module in Python provides a way to interact with the operating system, offering a wide range of functions for file and directory handling. It allows you to perform operations that are typically done at the command line or through a graphical file manager, directly within your Python scripts.

Q.23 What are the challenges associated with memory management in Python?

      --> Python's automatic memory management, while simplifying development, presents several challenges:

      * Overhead of Reference Counting:
        - Python utilizes reference counting to track object references. This mechanism requires extra memory to store the reference count for each object. In applications with a large number of small objects, this overhead can become significant.

      * Handling Circular References:
        - Reference counting alone cannot detect and reclaim memory occupied by circular references, where two or more objects mutually reference each other, preventing their reference counts from dropping to zero even when no external references exist. Python's generational garbage collector addresses this by periodically identifying and collecting such cycles.

      * Dynamic Memory Allocation Overhead:
        - Python objects are dynamically allocated at runtime. This process involves the interpreter searching for and allocating suitable memory blocks, which can introduce overhead compared to languages with static memory allocation.

      * Garbage Collector Pauses:
        - The garbage collector runs periodically to reclaim unused memory. In memory-intensive applications or those creating numerous objects, these collection cycles can lead to brief pauses in program execution, potentially impacting performance, especially in real-time or latency-sensitive systems.

      * Memory Leaks with Unclosed Resources:
        - While Python manages object memory, it does not automatically manage external resources like file handles, network sockets, or database connections. Failing to explicitly close these resources can lead to memory leaks and resource exhaustion.

      * String Immutability and Concatenation:
        - Python strings are immutable. Repeated string concatenation using the + operator creates new string objects in memory for each operation, which can be inefficient and memory-intensive for large or frequently modified strings. Using methods like join() or f-strings is more memory-efficient for string manipulation.

      * Limited Manual Control:
        - Compared to languages like C++, Python offers less granular control over memory allocation and deallocation, which can be a limitation in scenarios requiring fine-tuned memory optimization.

Q.24 How do you raise an exception manually in Python?

      --> In Python, exceptions are raised using the raise keyword. This allows you to explicitly trigger an error condition and stop the normal flow of program execution.

      Syntax:

              raise ExceptionType("Optional error message")

      Examples:

      * Raising a built-in exception.      


        def calculate_division(numerator, denominator):
        if denominator == 0:
        raise ZeroDivisionError("Cannot divide by zero!")
        return numerator / denominator

        try:
        result = calculate_division(10, 0)
        print(result)
        except ZeroDivisionError as e:
        print(f"Error: {e}")

     * Raising a custom exception.

      You can define your own custom exceptions by inheriting from the built-in Exception class or a more specific exception class.

        class InvalidAgeError(Exception):
        '''Custom exception for invalid age values.'''
        pass

        def set_age(age):
        if age < 0 or age > 120:
        raise InvalidAgeError("Age must be between 0 and 120.")
        print(f"Age set to: {age}")

        try:
        set_age(150)
        except InvalidAgeError as e:
        print(f"Validation Error: {e}")  
        
      * Re-raising an exception.

      Within an except block, you can re-raise the caught exception to propagate it further up the call stack.

        def process_data(data):
        try:
        # Some operation that might raise an error
        result = 10 / data
        except TypeError as e:
            print("Caught a TypeError, re-raising it...")
            raise  # Re-raises the current exception

        try:
        process_data("abc")
        except TypeError as e:
        print(f"Handled re-raised error: {e}")

        Key Points:

        * The raise statement immediately stops the current execution and transfers control to the nearest except block that can handle the raised exception type.

        * You can include an optional error message as an argument to the exception constructor, which provides more context about the error.

        * Custom exceptions help in creating more specific and descriptive error handling within your applications.

Q.25  Why is it important to use multithreading in certain applications?

       --> Multithreading is crucial for applications needing responsiveness, performance, and scalability by allowing them to perform multiple tasks concurrently, such as a web server handling numerous requests or a desktop application responding to user input while performing background operations. It enhances CPU utilization by leveraging multiple cores and improves resource efficiency by enabling threads within a single process to share memory, reducing overhead compared to using separate processes.

# Practical Questions

Q.1 How can you open a file for writing in Python and write a string to it?
"""

with open("my_output_file.txt", "w") as file:
  file.write("Hello, this is a string written to the file.")

print("String successfully written to 'my_output_file.txt'")

"""Q.2 Write a Python program to read the contents of a file and print each line."""

with open("my_output_file.txt", "r") as file:
  line = file.readline()
  while line:
    print(line.strip())
    line = file.readline()

"""Q.3 How would you handle a case where the file doesn't exist while trying to open it for reading?"""

try:
  with open("non_existent_file.txt", "r") as file:
    content = file.read()
    print(content)
except FileNotFoundError:
  print("Error: The file was not found.")

"""Q.4 Write a Python script that reads from one file and writes its content to another file."""

try:
  # Open the source file for reading
  with open("my_output_file.txt", "r") as source_file:
    # Read the entire content of the source file
    content = source_file.read()

  # Open the destination file for writing
  with open("my_copied_file.txt", "w") as destination_file:
    # Write the content to the destination file
    destination_file.write(content)

  print("Content successfully copied from 'my_output_file.txt' to 'my_copied_file.txt'")

except FileNotFoundError:
  print("Error: The source file 'my_output_file.txt' was not found.")
except Exception as e:
  print(f"An error occurred: {e}")

"""Q.5 How would you catch and handle division by zero error in Python?

"""

def divide_numbers(a, b):
  try:
    result = a / b
    print(f"The result of division is: {result}")
  except ZeroDivisionError:
    print("Error: Cannot divide by zero!")
  except TypeError:
    print("Error: Invalid input types.")

# Example usage
divide_numbers(10, 2)
divide_numbers(10, 0)
divide_numbers(10, "a")

"""Q.6 Write a Python program that logs an error message to a log file when a division by zero exception occurs."""

import logging

# Configure logging to write to a file named 'app.log'
logging.basicConfig(filename='app.log', level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

def divide_numbers_with_logging(a, b):
  try:
    result = a / b
    print(f"The result of division is: {result}")
  except ZeroDivisionError:
    # Log an error message to the file
    logging.error("Attempted to divide by zero!")
    print("Error: Cannot divide by zero! An error has been logged.")
  except TypeError:
    # Log a different error message for TypeError
    logging.error("Invalid input types for division!")
    print("Error: Invalid input types! An error has been logged.")


# Example usage
divide_numbers_with_logging(10, 2)
divide_numbers_with_logging(10, 0)
divide_numbers_with_logging(10, "a")

"""Q.7 How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module?"""

import logging

# Configure the logging level (e.g., to display INFO messages and above)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Log messages at different levels
logging.debug("This is a debug message (won't be displayed with INFO level)")
logging.info("This is an informational message.")
logging.warning("This is a warning message.")
logging.error("This is an error message.")
logging.critical("This is a critical message.")

# You can also create a logger instance
logger = logging.getLogger("my_app")
logger.setLevel(logging.DEBUG) # Set the logging level for this specific logger

# Create a console handler and set its level
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# Create a formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Add formatter to ch
ch.setFormatter(formatter)

# Add ch to logger
logger.addHandler(ch)

# Log messages using the logger instance
logger.debug("This is a debug message from my_app logger.")
logger.info("This is an info message from my_app logger.")

"""Q.8  Write a program to handle a file opening error using exception handling."""

def safe_file_open(filename, mode):
  try:
    file = open(filename, mode)
    print(f"File '{filename}' opened successfully in mode '{mode}'.")
    # Remember to close the file when done with it,
    # or use a 'with' statement for automatic closing.
    file.close()
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
  except PermissionError:
    print(f"Error: Permission denied to access file '{filename}'.")
  except Exception as e:
    print(f"An unexpected error occurred while opening file '{filename}': {e}")

# Example usage:
safe_file_open("my_output_file.txt", "r") # Existing file
safe_file_open("non_existent_file.txt", "r") # Non-existent file
safe_file_open("/root/some_restricted_file.txt", "r") # Potential permission error (depending on environment)

"""Q.9  How can you read a file line by line and store its content in a list in Python."""

def read_file_to_list(filename):
  lines = []
  try:
    with open(filename, 'r') as file:
      for line in file:
        lines.append(line.strip()) # .strip() removes leading/trailing whitespace, including newline characters
    return lines
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
    return None
  except Exception as e:
    print(f"An error occurred while reading file '{filename}': {e}")
    return None

# Example usage:
file_content_list = read_file_to_list("my_output_file.txt")

if file_content_list is not None:
  print("File content stored in a list:")
  print(file_content_list)

non_existent_file_content = read_file_to_list("non_existent_file.txt")

"""Q.10  How can you append data to an existing file in Python."""

# Open the file in append mode ('a')
with open("my_output_file.txt", "a") as file:
  # Append a new line of text
  file.write("\nThis line is appended to the file.")

print("Data successfully appended to 'my_output_file.txt'")

# Verify the content by reading the file
with open("my_output_file.txt", "r") as file:
  updated_content = file.read()
  print("\nUpdated file content:")
  print(updated_content)

"""Q.11 Write a Python program that uses a try-except block to handle an error when attempting to access a
dictionary key that doesn't exist.
"""

my_dict = {"name": "Alice", "age": 30}

try:
  # Attempt to access a key that doesn't exist
  city = my_dict["city"]
  print(f"City: {city}")
except KeyError:
  print("Error: The specified dictionary key was not found.")
except Exception as e:
  print(f"An unexpected error occurred: {e}")

# Example of accessing an existing key
try:
  name = my_dict["name"]
  print(f"Name: {name}")
except KeyError:
  print("Error: The specified dictionary key was not found.")

"""Q.12 Write a program that demonstrates using multiple except blocks to handle different types of exceptions."""

def process_input(value):
  try:
    # Attempt to convert the value to an integer
    num = int(value)
    # Perform a calculation that might raise a ValueError
    if num < 0:
      raise ValueError("Input cannot be negative")
    result = 10 / num
    print(f"Result: {result}")
  except ValueError as ve:
    print(f"Caught a ValueError: {ve}")
  except TypeError as te:
    print(f"Caught a TypeError: {te}")
  except ZeroDivisionError:
    print("Caught a ZeroDivisionError: Cannot divide by zero!")
  except Exception as e:
    print(f"Caught an unexpected exception: {e}")

# Example usage with different input types
process_input("5")      # Valid input
process_input("abc")    # Raises ValueError (from int conversion)
process_input("-2")     # Raises ValueError (custom)
process_input(0)        # Raises ZeroDivisionError
process_input([1, 2])   # Raises TypeError

"""Q.13  How would you check if a file exists before attempting to read it in Python."""

import os

def read_file_if_exists(filename):
  if os.path.exists(filename):
    try:
      with open(filename, 'r') as file:
        content = file.read()
        print(f"Content of '{filename}':")
        print(content)
    except Exception as e:
      print(f"An error occurred while reading file '{filename}': {e}")
  else:
    print(f"Error: File '{filename}' does not exist.")

# Example usage:
read_file_if_exists("my_output_file.txt") # Existing file
read_file_if_exists("non_existent_file.txt") # Non-existent file

"""Q.14 Write a program that uses the logging module to log both informational and error messages."""

import logging

# Configure logging to display INFO messages and above
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def example_function(value):
  try:
    if value > 10:
      logging.info(f"Value {value} is greater than 10.")
    else:
      logging.info(f"Value {value} is not greater than 10.")

    result = 100 / value
    logging.info(f"Result of division: {result}")

  except ZeroDivisionError:
    logging.error("Attempted to divide by zero!")
    print("Error: Cannot divide by zero!")
  except Exception as e:
    logging.error(f"An unexpected error occurred: {e}")
    print(f"An error occurred: {e}")


# Example usage:
example_function(20)
example_function(5)
example_function(0)
example_function("abc")

"""Q.15 Write a Python program that prints the content of a file and handles the case when the file is empty."""

def print_file_content(filename):
  try:
    with open(filename, 'r') as file:
      content = file.read()
      if content:  # Check if the content is not empty
        print(f"Content of '{filename}':")
        print(content)
      else:
        print(f"File '{filename}' is empty.")
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
  except Exception as e:
    print(f"An error occurred while reading file '{filename}': {e}")

# Example usage:
print_file_content("my_output_file.txt") # Existing file with content

# Create an empty file for demonstration
with open("empty_file.txt", "w") as empty_file:
  pass # Create an empty file

print_file_content("empty_file.txt") # Empty file
print_file_content("non_existent_file.txt") # Non-existent file

"""Q.16 Demonstrate how to use memory profiling to check the memory usage of a small program."""

# Commented out IPython magic to ensure Python compatibility.
# %pip install memory_profiler

# my_program.py - This part is for demonstrating how to run from command line,
#                  but we can directly run the function in Colab.
from memory_profiler import profile

@profile
def my_function():
    a = [i for i in range(1000000)]  # Create a large list
    b = [j * 2 for j in a]       # Create another large list
    del a                       # Delete 'a' to free memory
    return b

if __name__ == '__main__':
    # When running this in a .py file from the command line using
    # python -m memory_profiler my_program.py, this block will execute.
    # In a Colab notebook, we can just call the function directly.
    result = my_function()
    print(f"Function executed. Length of result: {len(result)}")

# To run the profiled function directly in Colab, you can call it here:
# result = my_function()
# print(f"Function executed. Length of result: {len(result)}")

# Note: The line-by-line memory usage output generated by @profile
# will be printed to stderr when the cell containing the function call is run.

"""Q.17 Write a Python program to create and write a list of numbers to a file, one number per line."""

def write_numbers_to_file(numbers, filename="numbers.txt"):
    """
    Writes a list of numbers to a file, with each number on a new line.

    Args:
        numbers (list): A list of numbers (integers or floats).
        filename (str): The name of the file to write to.
    """
    try:
        with open(filename, 'w') as file:
            for number in numbers:
                file.write(str(number) + '\n')
        print(f"Numbers successfully written to {filename}")
    except IOError as e:
        print(f"Error writing to file: {e}")

if __name__ == "__main__":
    # Create a sample list of numbers
    my_numbers = [10, 25, 3.14, 42, 5.0, 600]

    # Call the function to write the numbers to a file
    write_numbers_to_file(my_numbers)

    # You can also specify a different filename
    write_numbers_to_file([7, 8, 9], "another_numbers_file.txt")

"""Q.18 How would you implement a basic logging setup that logs to a file with rotation after 1MB."""

import logging
from logging.handlers import RotatingFileHandler
import os

# Define the log file path
log_file = "rotating_app.log"

# Configure the RotatingFileHandler
# maxBytes is the maximum size of the log file in bytes (1MB = 1024 * 1024 bytes)
# backupCount is the number of backup log files to keep
handler = RotatingFileHandler(log_file, maxBytes=1024 * 1024, backupCount=5)

# Create a formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Set the formatter for the handler
handler.setFormatter(formatter)

# Get the root logger
logger = logging.getLogger()
logger.setLevel(logging.INFO) # Set the minimum logging level

# Add the handler to the logger
logger.addHandler(handler)

# Example logging messages
logger.info("This is an informational message.")
logger.warning("This is a warning message.")
logger.error("This is an error message.")

# To demonstrate rotation, you would need to write enough log messages
# to exceed the maxBytes. This example just sets up the handler.
print(f"Logging configured to '{log_file}' with rotation.")

# You can optionally remove the log file(s) created by this example
# import os
# if os.path.exists(log_file):
#     os.remove(log_file)
# for i in range(handler.backupCount):
#     if os.path.exists(f"{log_file}.{i+1}"):
#         os.remove(f"{log_file}.{i+1}")

"""Q.19 Write a program that handles both IndexError and KeyError using a try-except block."""

def access_data(data_structure, key_or_index):
  try:
    # Attempt to access data
    value = data_structure[key_or_index]
    print(f"Accessed value: {value}")
  except (IndexError, KeyError):
    print(f"Error: Invalid index or key '{key_or_index}' for the data structure.")
  except Exception as e:
    print(f"An unexpected error occurred: {e}")

# Example usage with a list
my_list = [10, 20, 30]
access_data(my_list, 1)     # Valid index
access_data(my_list, 5)     # IndexError

# Example usage with a dictionary
my_dict = {"a": 1, "b": 2}
access_data(my_dict, "a")   # Valid key
access_data(my_dict, "c")   # KeyError

"""Q.20 How would you open a file and read its contents using a context manager in Python."""

def read_file_with_context_manager(filename):
  try:
    # Use a context manager to open and automatically close the file
    with open(filename, 'r') as file:
      content = file.read()
      print(f"Content of '{filename}':")
      print(content)
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
  except Exception as e:
    print(f"An error occurred while reading file '{filename}': {e}")

# Example usage:
read_file_with_context_manager("my_output_file.txt") # Existing file
read_file_with_context_manager("non_existent_file.txt") # Non-existent file

"""Q.21 Write a Python program that reads a file and prints the number of occurrences of a specific word."""

import re

def count_word_occurrences(filename, word):
  try:
    with open(filename, 'r') as file:
      content = file.read()
      # Use regex to find all occurrences of the word (case-insensitive)
      # re.findall returns a list of all matches
      occurrences = re.findall(r'\b' + re.escape(word) + r'\b', content, re.IGNORECASE)
      count = len(occurrences)
      print(f"The word '{word}' appears {count} times in '{filename}'.")
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
  except Exception as e:
    print(f"An error occurred while reading file '{filename}': {e}")

# Example usage:
count_word_occurrences("my_output_file.txt", "this")
count_word_occurrences("my_output_file.txt", "file")
count_word_occurrences("non_existent_file.txt", "test")

"""Q.22 How can you check if a file is empty before attempting to read its contents."""

def is_file_empty_read(filename):
  """Checks if a file is empty by attempting to read a small amount."""
  try:
    with open(filename, 'r') as file:
      # Read one character. If it's empty, the file is empty.
      content = file.read(1)
      return not bool(content)
  except FileNotFoundError:
    print(f"Error: File '{filename}' not found.")
    return False # Or raise the exception, depending on desired behavior
  except Exception as e:
    print(f"An error occurred while reading file: {e}")
    return False # Or raise the exception

# Example usage:
empty_file_name = "empty_file_for_check_2.txt"
non_empty_file_name = "my_output_file.txt"
non_existent_file = "non_existent_file_to_check_2.txt"

# Create an empty file for demonstration
with open(empty_file_name, "w") as f:
    pass

print(f"Is '{empty_file_name}' empty? {is_file_empty_read(empty_file_name)}")
print(f"Is '{non_empty_file_name}' empty? {is_file_empty_read(non_empty_file_name)}")
print(f"Is '{non_existent_file}' empty? {is_file_empty_read(non_existent_file)}")

# Clean up the empty file
os.remove(empty_file_name)

"""Q.23  Write a Python program that writes to a log file when an error occurs during file handling."""

import logging

# Configure logging to write to a file named 'file_errors.log'
logging.basicConfig(filename='file_errors.log', level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

def write_to_file_safely(filename, content):
  try:
    with open(filename, 'w') as file:
      file.write(content)
    print(f"Content successfully written to '{filename}'.")
  except IOError as e:
    # Log an error message if an IOError occurs
    logging.error(f"Error writing to file '{filename}': {e}")
    print(f"Error: Could not write to file '{filename}'. An error has been logged.")
  except Exception as e:
    # Log any other unexpected exceptions
    logging.error(f"An unexpected error occurred while handling file '{filename}': {e}")
    print(f"An unexpected error occurred while handling file '{filename}'. An error has been logged.")

# Example usage:
write_to_file_safely("my_new_file.txt", "This is some content.") # Successful write
write_to_file_safely("/non_existent_directory/my_error_file.txt", "This should cause an error.") # Will cause an IOError

"""# END"""